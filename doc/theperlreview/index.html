<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">

<!--Converted with LaTeX2HTML 2008 (1.71)
original version by:  Nikos Drakos, CBLU, University of Leeds
* revised and updated by:  Marcus Hennecke, Ross Moore, Herb Swan
* with significant contributions from:
  Jens Lippmann, Marek Rouchal, Martin Wilck and others -->
<HTML>
<HEAD>
<TITLE>Parsing Strings and Trees with Parse::Eyapp
(An Introduction to Compiler Construction)</TITLE>
<META NAME="description" CONTENT="Parsing Strings and Trees with Parse::Eyapp
(An Introduction to Compiler Construction)">
<META NAME="keywords" CONTENT="theperlreview">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">

<META NAME="Generator" CONTENT="LaTeX2HTML v2008">
<META HTTP-EQUIV="Content-Style-Type" CONTENT="text/css">

<LINK REL="STYLESHEET" HREF="theperlreview.css">

</HEAD>

<BODY >
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="file:/opt/local/share/lib/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/opt/local/share/lib/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/opt/local/share/lib/latex2html/icons/prev_g.png">   
  <A NAME="tex2html1"
  HREF="http://nereida.deioc.ull.es/~pl/eyapsimple/source.tgz"><IMG
  WIDTH="23" ALIGN="BOTTOM" BORDER="0"
 SRC="gzip.png"
 ALT="SRC"></A>

  <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/eyapsimple/eyapsimple.dvi"><IMG
  WIDTH="23" ALIGN="BOTTOM" BORDER="0"
 SRC="xdviicon.gif"
 ALT="DVI"></A>
<A NAME="tex2html3"
  HREF="eyapsimple.ps"><IMG
  WIDTH="24" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="eyapsimple.ps"></A><A NAME="tex2html4"
  HREF="eyapsimple.pdf"><IMG
  WIDTH="24" ALIGN="BOTTOM" BORDER="0"
 SRC="pdf_logo.jpg"
 ALT="eyapsimple.pdf"></A><A NAME="tex2html5"
  HREF="http://search.cpan.org/dist/Parse-Eyapp/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html6"
  HREF="../perlexamples/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="dragon_tree4.jpg"
 ALT="apuntes"></A><A NAME="tex2html7"
  HREF="http://www.parrot.org/"><IMG
  WIDTH="70" ALIGN="BOTTOM" BORDER="0"
 SRC="parrotify_logo.png"
 ALT="modulos"></A>
<BR>
<BR><BR>
<!--End of Navigation Panel-->

<P>
<H1 ALIGN="CENTER">Parsing Strings and Trees with <TT>Parse::Eyapp</TT>
<BR><I>(An Introduction to Compiler Construction)</I></H1><DIV>

<P ALIGN="CENTER"><STRONG>Casiano Rodriguez-Leon</STRONG></P>
<P ALIGN="CENTER"><I>Dpto. Estad&#237;stica, I.O. y Computaci&#243;n.
Universidad de La Laguna
</I></P>
</DIV>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<P>

<H3>Abstract:</H3>
<DIV>
<A NAME="tex2html8"
  HREF="http://search.cpan.org/perldoc?Parse::Eyapp">Parse::Eyapp</A>
(Extended yapp) is a collection of modules
that extends Francois Desarmenien Parse::Yapp 1.05.
Eyapp extends yacc/yapp syntax with 
functionalities like named attributes,
EBNF-like expressions, modifiable default action,
automatic abstract syntax tree building,
dynamic conflict resolution,
translation schemes, tree regular expressions,
tree transformations, scope analysis support,
and directed acyclic graphs among others.

<P>
This article teaches you the basics of 
Compiler Construction using <A NAME="tex2html9"
  HREF="http://search.cpan.org/perldoc?Parse::Eyapp">Parse::Eyapp</A>
to
build a translator from infix expressions to Parrot 
Intermediate Representation.
</DIV>
<P>

<P>

<H1><A NAME="SECTION00010000000000000000"></A>
<A NAME="section:introduction"></A><BR>
Introduction
</H1>
Almost any Perl programmer knows what <I>Parsing</I> is about.
One of the strengths of Perl is its excellence for text analysis. 
Additionally to its embedded regular expression capacities, modules 
like <A NAME="tex2html10"
  HREF="http://search.cpan.org/perldoc?Parse::RecDescent">Parse::RecDescent</A>
[<A
 HREF="theperlreview.html#conwayrd">1</A>] and 
<A NAME="tex2html11"
  HREF="http://search.cpan.org/perldoc?Parse::Yapp">Parse::Yapp</A>
[<A
 HREF="theperlreview.html#desarmenien">2</A>] make easier the task of text 
understanding and text transformation.

<P>
<A NAME="tex2html12"
  HREF="http://search.cpan.org/perldoc?Parse::Eyapp">Parse::Eyapp</A>
(Extended yapp) is a collection of modules
that extends Francois Desarmenien <A NAME="tex2html13"
  HREF="http://search.cpan.org/perldoc?Parse::Yapp">Parse::Yapp</A>
<TT>1.05</TT>:
Any <TT>yapp</TT> program runs without changes with <A NAME="tex2html14"
  HREF="http://search.cpan.org/perldoc?eyapp">eyapp</A>.
Additionally <A NAME="tex2html15"
  HREF="http://search.cpan.org/perldoc?Parse::Eyapp">Parse::Eyapp</A>
provides new 
functionalities like named attributes,
EBNF-like expressions, modifiable default actions,
abstract syntax tree building and translation schemes. 
It also provides a language for tree transformations.

<P>
This article introduces the basics of 
translator construction with <A NAME="tex2html16"
  HREF="http://search.cpan.org/perldoc?Parse::Eyapp">Parse::Eyapp</A>
through an
example that compiles infix expressions into <A NAME="tex2html17"
  HREF="http://search.cpan.org/perldoc?Parrot">Parrot</A>
Intermediate Representation (PIR)[<A
 HREF="theperlreview.html#randal04">3</A>].
<A NAME="tex2html18"
  HREF="http://search.cpan.org/perldoc?Parrot">Parrot</A>
is a virtual machine (VM), similar to the Java VM and the
.NET VM. However, unlike these two which are designed for
statically-typed languages like Java or C#, <A NAME="tex2html19"
  HREF="http://search.cpan.org/perldoc?Parrot">Parrot</A>
is designed for
use with dynamically typed languages such as Perl, Python, Ruby,
or PHP.

<P>
The input to the program will be a (semicolon separated)
list of infix expressions, like in this example 
located in file <code>input1.inf</code>:
<PRE>
$ cat input1.inf 
b = 5;
a = b+2;
a = 2*(a+b)*(2-4/2);
print a;
d = (a = a+1)*4-b;
c = a*b+d;
print c;
print d
</PRE>

<P>
and the output is the
PIR resulting from the translation: 
<PRE>
 1  .sub 'main' :main
 2     .local num a, b, c, d
 3     b = 5
 4     a = b + 2
 5     a = 0 # expression at line 3 
 6     print "a = "     # above was
 7     print a    # reduced to zero
 8     print "\n" # at compile time
 9     a = a + 1
10     $N5 = a * 4
11     d = $N5 - b
12     $N7 = a * b
13     c = $N7 + d
14     print "c = "
15     print c
16     print "\n"
17     print "d = "
18     print d
19     print "\n"
20  .end
</PRE>

<P>
You can download the code for this example from
<A NAME="tex2html20"
  HREF="http://nereida.deioc.ull.es/~pl/eyapsimple/source.tgz">http://nereida.deioc.ull.es/~pl/eyapsimple/source.tgz</A>.
To use it, unpack the tarball:
<PRE>
tar xvzf source.tgz
</PRE>
Change to the directory:
<PRE>
cd src
</PRE>
and compile the grammar with <code>eyapp</code>:
<PRE>
eyapp Infix.eyp
</PRE>
Compile also the set of tree transformations using <code>treereg</code>:
<PRE>
treereg -m main I2PIR.trg
</PRE>
After these two compilations we have two new modules:
<PRE>
nereida:/tmp/src&gt; ls -ltr |tail -2
-rw-rw----  1 pl users   Infix.pm
-rw-rw----  1 pl users   I2PIR.pm
</PRE>
Module <code>Infix.pm</code> contains the parser for the grammar described in <code>Infix.eyp</code>.
Module <code>I2PIR.pm</code> contains the collection of tree transformations described
in <code>I2PIR.trg</code>. Now we can run the script <code>infix2pir.pl</code> which makes use of these
two modules:
<PRE>
$ ./infix2pir.pl input1.inf &gt; input1.pir
</PRE>
We can now make use of the <code>parrot</code> interpreter to execute the code:
<PRE>
$ /Users/casianorodriguezleon/src/parrot/parrot-1.9.0/parrot input1.pir 
a = 0
c = 4
d = -1
</PRE>

<P>

<H1><A NAME="SECTION00020000000000000000"></A>
<A NAME="section:parrot"></A><BR>
A Fast Introduction to Parrot
</H1>
The <A NAME="tex2html21"
  HREF="http://search.cpan.org/perldoc?Parrot">Parrot</A>
virtual machine [<A
 HREF="theperlreview.html#parrot">4</A>] is register based. This means that, like a hardware
CPU, it has a number of fast-access units of storage called registers.
There are 4 types of register in <A NAME="tex2html22"
  HREF="http://search.cpan.org/perldoc?Parrot">Parrot</A>: integers (<code>I</code>), numbers (<code>N</code>),
strings (<code>S</code>) and PMCs (<code>P</code>). For each type there are several of these, named
<code>$N0</code>, <code>$N1</code>, ...Number registers map
to the machine native floating point type. 
You can download a recent version of parrot from
<A NAME="tex2html23"
  HREF="http://www.parrot.org/download">http://www.parrot.org/download</A>.

<P>
The code produced by <code>infix2pir.pl</code> is an example of <A NAME="tex2html24"
  HREF="http://search.cpan.org/perldoc?docs/user/pir/intro.pod">PIR</A>, which stands for 
<A NAME="tex2html25"
  HREF="http://search.cpan.org/perldoc?Parrot">Parrot</A>
Intermediate Representation and is also known as
Intermediate Code or IMC. <A NAME="tex2html26"
  HREF="http://search.cpan.org/perldoc?docs/user/pir/intro.pod">PIR</A>
files use the extension <code>.pir</code>.
<A NAME="tex2html27"
  HREF="http://search.cpan.org/perldoc?docs/user/pir/intro.pod">PIR</A>
is an intermediate language that can be compiled to
<A NAME="tex2html28"
  HREF="http://search.cpan.org/perldoc?Parrot">Parrot</A>
Byte code (PBC). It was conceived as a possible target language for compilers
targeting the <A NAME="tex2html29"
  HREF="http://search.cpan.org/perldoc?Parrot">Parrot</A>
Virtual Machine. <A NAME="tex2html30"
  HREF="http://search.cpan.org/perldoc?docs/user/pir/intro.pod">PIR</A>
is halfway between a High
Level Language (HLL) and <A NAME="tex2html31"
  HREF="http://search.cpan.org/perldoc?Parrot">Parrot</A>
Assembly (<A NAME="tex2html32"
  HREF="http://search.cpan.org/perldoc?docs/book/ch05_pasm.pod">PASM</A>).

<P>
<A NAME="tex2html33"
  HREF="http://search.cpan.org/perldoc?docs/user/pir/intro.pod">PIR</A>
has a relatively simple syntax. Every line is a comment, a
label, a statement, or a directive. Each statement or directive
stands on its own line. There is no end-of-line symbol (such as a
semicolon in C). These is a brief enumeration of the main characteristics of the language:

<P>

<UL>
<LI><B>Comments </B>
A comment begins with the <code>#</code> symbol, and continues until the end of
the line. Comments can stand alone on a line or follow a statement
or directive.

<P>
</LI>
<LI><B>Statements </B>

<P>
A statement is either an opcode or syntactic sugar for one or more
opcodes. An opcode is a native instruction for the virtual machine;
it consists of the name of the instruction followed by zero or more
arguments.

<P>
</LI>
<LI><B>Higher-level constructs </B>

<P>
<A NAME="tex2html34"
  HREF="http://search.cpan.org/perldoc?docs/user/pir/intro.pod">PIR</A>
also provides higher-level constructs, including symbolic operators:

<P>
<PRE>
  $I1 = 2 + 5
</PRE>

<P>
These special statement forms are just syntactic sugar for regular
opcodes. The <code>+</code> symbol corresponds to the <code>add</code> opcode, the 
<code>-</code> symbol
to the <code>sub</code> opcode, and so on. The previous example is equivalent
to:

<P>
<PRE>
  add $I1, 2, 5
</PRE>

<P>
</LI>
<LI><B>Directives </B>

<P>
Directives resemble opcodes, but they begin with a period (<code>.</code>). Some
directives specify actions that occur at compile time. Other
directives represent complex operations that require the generation
of multiple instructions. The <code>.local</code> directive, for example, declares
a named variable.

<P>
<PRE>
  .local string hello
</PRE>

<P>
</LI>
<LI><B>Literals </B>

<P>

<UL>
<LI><B>Numbers </B>

<P>
Integers and floating point numbers are numeric literals. They can be positive or negative.
Integer literals can also be binary, octal, or hexadecimal:

<P>
<PRE>
  $I0 = 42       # positive
  $I1 = -1       # negative
  $I1 = 0b01010  # binary
  $I2 = 0o72     # octal
  $I3 = 0xA5     # hexadecimal
</PRE>

<P>
Floating point number literals have a decimal point and can use scientific notation:

<P>
<PRE>
  $N0 = 3.14
  $N2 = -1.2e+4
</PRE>

<P>
</LI>
<LI><B>Strings </B>

<P>
String literals are enclosed in single or double-quotes.
Strings in double-quotes allow escape sequences using backslashes.
Strings in single-quotes only allow escapes for nested quotes

<P>
<PRE>
  $S0 = "This is a valid literal string"
  $S1 = 'This is also a valid literal string'
</PRE>
</LI>
</UL>

<P>
</LI>
<LI><B>Variables </B>

<P>
<A NAME="tex2html35"
  HREF="http://search.cpan.org/perldoc?docs/user/pir/intro.pod">PIR</A>
variables can store four different kinds of valuesâ€”integers,
numbers (floating point), strings, and objects. <A NAME="tex2html36"
  HREF="http://search.cpan.org/perldoc?Parrot">Parrot</A>'s objects
are called PMCs, for "PolyMorphic Container".

<P>
The simplest kind of variable is a register variable. The name of
a register variable always starts with a dollar sign (<code>$</code>), followed
by a single character which specifies the type of the variable -
integer (<code>I</code>), number (<code>N</code>), string (<code>S</code>), or PMC (<code>P</code>) 
- and ends with a unique number. You need not predeclare register variables:

<P>
<PRE>
  $S0 = "Who's a pretty boy, then?"
  say $S0
</PRE>

<P>
<A NAME="tex2html37"
  HREF="http://search.cpan.org/perldoc?docs/user/pir/intro.pod">PIR</A>
also has named variables; the <code>.local</code> directive declares them.
As with register variables, there are four valid types: <code>int</code>, <code>num</code>,
<code>string</code>, and <code>pmc</code>. You must declare named variables; otherwise they
behave exactly the same as register variables.

<P>
<PRE>
  .local string hello
  hello = "'Allo, 'allo, 'allo."
  say hello
</PRE>

<P>
</LI>
<LI><B>Constants </B>

<P>
The <code>.const</code> directive declares a named constant. Named constants are
similar to named variables, but the values set in the declaration
may never change. Like <code>.local</code>, <code>.const</code> takes a type and a name. It
also requires a literal argument to set the value of the constant.

<P>
<PRE>
  .const int    frog = 4                       # integer
  .const string name = "Superintendent Parrot" # string
  .const num    pi   = 3.14159                 # floating point
</PRE>

<P>
You may use a named constant anywhere you may use a literal, but
you must declare the named constant beforehand. 

<P>
</LI>
<LI><B>Keys </B>

<P>
A key is a special kind of constant used for accessing elements in
complex variables (such as an array). A key is either an integer
or a string; and it's always enclosed in square brackets 
(<code>[</code> and <code>]</code>).
You do not have to declare literal keys. This code example stores
the string <code>"foo"</code>
in <code>$P0</code> as element <code>5</code>, and then retrieves it.

<P>
<PRE>
  $P0[5] = "foo"
  $S1    = $P0[5]
</PRE>

<P>
<A NAME="tex2html38"
  HREF="http://search.cpan.org/perldoc?docs/user/pir/intro.pod">PIR</A>
supports multi-part keys. Use a semicolon to separate each part.

<P>
<PRE>
  $P0['my';'key'] = 472
  $I1             = $P0['my';'key']
</PRE>

<P>
</LI>
<LI><B>Control Structures </B>

<P>

<UL>
<LI><B>goto</B>

<P>
The <code>goto label</code> statement 
jumps to a named label. It can only
jump inside a subroutine, and only to a named label. 
Example:

<P>
<PRE>
    goto GREET
      # ... some skipped code ...
  GREET:
    say "'Allo, 'allo, 'allo."
</PRE>

<P>
</LI>
<LI><B>if </B>

<P>
Variations on the basic <code>goto</code> check whether a particular condition
is true or false before jumping:

<P>
<PRE>
  if $I0 &gt; 5 goto GREET
</PRE>
</LI>
</UL>

<P>
</LI>
<LI><B>Subroutines </B>

<P>
A <A NAME="tex2html39"
  HREF="http://search.cpan.org/perldoc?docs/user/pir/intro.pod">PIR</A>
subroutine starts with the <code>.sub</code> directive and ends with the
<code>.end</code> directive. 
Parameter declarations use the <code>.param</code> directive;
they resemble named variable declarations. 

<P>
This example declares a
subroutine named greeting, that takes a single string parameter
named <code>hello</code>:

<P>
<PRE>
  .sub 'greeting'
      .param string hello
      say hello
  .end
</PRE>
</LI>
</UL>

<P>

<H1><A NAME="SECTION00030000000000000000"></A>
<A NAME="section:phases"></A><BR>
The Phases of a Translator
</H1>
The code below 
(file <code>src/infix2pir.pl</code>) displays
the stages of the translator: <I>Lexical
and syntax analysis, tree transformations
and decorations,
address assignments, code generation
and peephole optimization</I>. The simplicity of the 
considered language (no types, no control structures) 
permits the skipping of 
<I>context handling</I> (also called <I>semantic analysis</I>).
Context handling includes jobs like <I>type checking</I>, 
<I>live analysis</I>, etc.
Don't get overflowed for so much terminology:
The incoming sections will
explain in more detail each of these phases.
<PRE>
my $filename = shift;
my $parser = Infix-&gt;new(); 

# read input
$parser-&gt;slurp_file($filename);

# lexical and syntax analysis
my $t = $parser-&gt;YYParse();

# tree transformations:
# machine independent optimizations
$t-&gt;s(our @algebra);  

# Address Assignment 
our $reg_assign;
$reg_assign-&gt;s($t);

# Translate to PARROT
$t-&gt;bud(our @translation);

# variable declarations
my $dec = build_dec();

peephole_optimization($t-&gt;{tr});

output_code(\$t-&gt;{tr}, \$dec);
</PRE>

<P>
The compiler uses the parser for infix expressions
that was generated from the Eyapp grammar  <code>Infix.eyp</code>
(see section <A HREF="#section:syntacticanalysis">5</A>)
using the command:
<PRE>
$ eyapp Infix.eyp
$ ls -tr | tail -1
Infix.pm
</PRE>
It also uses the module containing different families of tree
transformations that are described in the <code>I2PIR.trg</code> file 
(explained in 
sections <A HREF="#section:machineindependentoptimizations">6</A> and <A HREF="#section:codegeneration">8</A>): 
<PRE>
$ treereg -m main I2PIR.trg
$ ls -tr | tail -1
I2PIR.pm
$ head -1 I2PIR.pm
package main;
</PRE>
The option <code>-m main</code> tells <code>treereg</code>
to place the generated tree transformations inside the <code>main</code>
namespace. Is in this file that the variables 
<code>@algebra</code>, <code>@translation</code> and 
<code>$reg_assign</code> used during the machine-independent optimization,
code generation and register allocation phases are defined.

<P>

<H1><A NAME="SECTION00040000000000000000"></A>
<A NAME="section:lexicalanalysis"></A><BR>
Lexical Analysis
</H1>
Lexical Analysis decomposes the input stream in a 
sequence of lexical units called <I>tokens</I>.
Associated with each token is its <I>attribute</I>
which carries the corresponding information.
In the code example below
the attribute associated with token <code>NUM</code>
is its numerical value and the attribute associated with 
token <code>VAR</code> is the actual string.
Each time the <I>parser</I>
requires a new token, the lexer returns
the couple <TT>(token, attribute)</TT> that matched.
Some tokens - like <code>PRINT</code> -  do not carry any special
information. In such cases, just to keep the protocol
simple, the lexer returns the couple <code>(token, token)</code>.
Using Eyapp terminology such tokens are called <I>syntactic tokens</I>.
On the other side, <I>Semantic tokens</I> are those tokens - like <code>VAR</code>
or <code>NUM</code> - whose attributes transport 
useful information. When the end of input is reached the lexer
returns the couple <code>('', undef)</code>.
The lexical analyzer can be specified
through the <code>%lexer</code> directive (see
the head section in file <code>examples/ParsingStringsAndTrees/Infix.eyp</code>of the 
<code>Parse::Eyapp</code> distribution):

<P>
<PRE>
%lexer  {
    m{\G[ \t]*}gc;
    m{\G(\n)+}gc                    and $self-&gt;tokenline($1 =~ tr/\n//);
    m{\G([0-9]+(?:\.[0-9]+)?)}gc    and return ('NUM',   $1);
    m{\Gprint}gc                    and return ('PRINT', 'PRINT');
    m{\G([A-Za-z_][A-Za-z0-9_]*)}gc and return ('VAR',   $1);
    m{\G(.)}gc                      and return ($1,      $1);
  }
</PRE>

<P>
The directive <code>%lexer</code> is followed by the code of the lexical analyzer.
Inside such code the variable <code>$_</code> contains the input string. The special
variable <code>$self</code> refers to the parser object. The pair <code>('', undef)</code>
is returned by the generated lexer when the end of input is detected.

<P>
When feed it with input <code>b = 1</code> the lexer
will produce the sequence 

<P>
<PRE>
          (VAR, 'b') ('=', '=') ('NUM', '1') ('', undef)
</PRE>

<P>
Lexical analyzers can have a non negligible impact in 
the overall performance. Ways to speed up this stage can be found 
in the works of Simoes [<A
 HREF="theperlreview.html#simoes">5</A>] and Tambouras [<A
 HREF="theperlreview.html#Tambouras">6</A>].

<P>

<H1><A NAME="SECTION00050000000000000000"></A>
<A NAME="section:syntacticanalysis"></A><BR>
Syntax Analysis
</H1>
The code below shows the body of the grammar (file 
<TT>Infix.eyp</TT>).
Eyapp syntax very much resembles the syntax of
old cherished <TT>yacc</TT> [<A
 HREF="theperlreview.html#yacc">7</A>].
An Eyapp program has three parts: <I>head</I>, <I>body</I> and <I>tail</I>.
Each part is separated from the former by the symbol <code>%%</code>.
The head section contains declarations, code support
and directives.
The grammar rules describing
the language - and the semantic actions that indicate how
evaluate the attributes associated with the symbols -
reside in the body section.
The tail section includes Perl code that gives support
to the semantic actions. Commonly 
the lexical analyzer and error diagnostic subroutines
go there. In the case of <code>eyapp</code> the lexical analyzer 
is usually defined through a <code>%lexer</code> directive inside 
the head section.  Also,
for most cases, there is no need to overwrite the provided default
<code>error</code> diagnostic method.

<P>
<PRE>
%right  '='        # Head section
%left   '-' '+'
%left   '*' '/'
%left   NEG
%tree 

%%
line:             # Body section
  sts &lt;%name EXPS + ';'&gt;
;
sts:
    %name PRINT
    PRINT leftvalue
  | exp 
;
exp:
    %name NUM    NUM
  | %name VAR    VAR
  | %name ASSIGN leftvalue '=' exp
  | %name PLUS   exp '+' exp
  | %name MINUS  exp '-' exp
  | %name TIMES  exp '*' exp
  | %name DIV    exp '/' exp
  | %name NEG
                '-' exp              %prec NEG
  |             '(' exp ')'
;
leftvalue : %name VAR VAR
;
%% 
</PRE>

<P>

<H2><A NAME="SECTION00051000000000000000">
Ambiguities and Conflicts</A>
</H2>
The former grammar is ambiguous.  
For instance, an expression like <code>exp '-' exp</code> followed by a
minus <code>'-'</code> can be worked in more than one way. An expression like:

<P>
<PRE>
               4 - 3 - 1
</PRE>

<P>
Is ambiguous. If you can't see it, it is because after so many years in 
school, your mind has ruled out one of the interpretations. Two interpretations
of the former phrase are:
<PRE>
               (4 - 3) - 1
               4 - (3 - 1)
</PRE>
In our planet the first interpretation is preferred over the second.

<P>
If we
have an input like <code>NUM - NUM - NUM</code> the activity of a LALR(1) parser
(the family of parsers to which Eyapp belongs)
consists of a sequence of <I>shift and reduce actions</I>:

<P>

<UL>
<LI>A <I>shift action</I>
has as consequence the reading of the next token. 

<P>
</LI>
<LI>A <I>reduce action</I>
is finding a production rule that matches and substituting 
the <I>right hand side</I> (rhs) of the production by the  <I>left hand side</I> (lhs).  
</LI>
</UL>

<P>
For input <code>NUM - NUM - NUM</code>
the activity will be as follows (the dot is used to indicate where the next 
input token is):

<P>
<PRE>
.NUM - NUM - NUM # shift
 NUM.- NUM - NUM # reduce exp: NUM 
 exp.- NUM - NUM # shift
 exp -.NUM - NUM # shift
 exp - NUM.- NUM # reduce exp: NUM
 exp - exp.- NUM # shift/reduce conflict
</PRE>
up to this point two different decisions can be taken: the next description can be
<PRE>
 exp.- NUM # reduce by exp: exp '-' exp
</PRE>
or:
<PRE>
 exp - exp -.NUM # shift '-'
</PRE>
that is called a <I>shift-reduce conflict</I>: the parser must decide
whether to shift <code>NUM</code> or to <I>reduce</I> by the rule <code>exp: exp - exp</code>.
A shift-reduce conflict means that the parser is not in condition to decide
whether to associate the processed phrase (left association) or to continue reading 
more input to make an association later (right association). This incapability
usually comes from the fact that the grammar is ambiguous but can also be due
to other reasons, as the myopic condition of the parser, being able only to see one token ahead.

<P>
Another kind of conflicts are <I>reduce-reduce conflicts</I>.
They arise when more that rhs can be applied for a reduction
action.

<P>
The precedence declarations in the 
head section tells the parser what to do in case of ambiguity. 

<P>
By associating priorities with tokens
the programmer can tell Eyapp what syntax tree
to build in case of <I>conflict</I>.

<P>
The declarations 
<code>%nonassoc</code>, <code>%left</code> and <code>%right</code> 
declare and associate a <I>priority</I> with the tokens
that follow them.  

<P>

<UL>
<LI>Tokens declared in the same line have the same precedence. 
</LI>
<LI>Tokens declared in lines below have more
precedence than those declared above. 
</LI>
<LI>The precedence of a rhs is the precedence of the rightmost token  
in that rhs. Thus, the production named <code>MINUS</code>: <code>exp -&gt; exp '-' exp</code>
has the precedence of <code>'-'</code>.
</LI>
<LI>We can always give an explicit priority to a rhs using the <code>%prec TOKEN</code> directive,
like in the rhs named <code>NEG</code>:
<PRE>
  | %name NEG
          '-' exp %prec NEG
</PRE>
</LI>
</UL>
When there is a shift-reduce conflict the precedence of the rule and the precedence of the
incoming token are compared

<UL>
<LI>If the precedence of the rule is greater, a reduction (left association) takes place
</LI>
<LI>If the precedence of the token is greater, a shift (right association) takes place
</LI>
<LI>If both token and rule have the same precedence the parser action depends on whether
the declaration was made using the <code>%left</code> or <code>%right</code> directive. In the
first case the reduction takes place, in the second the shift predominates.
</LI>
</UL>
Thus, in the example
we are saying that <code>'+'</code> and <code>'-'</code> have the same precedence
but higher than <code>'='</code>. The final effect of <code>'-'</code>
having greater precedence than <code>'='</code> is that an
expression like <code>a=4-5</code> is interpreted as <code>a=(4-5)</code> 
and not as <code>(a=4)-5</code>.  

<P>
The use of <code>%left</code> applied to <code>'-'</code>
indicates that, in case of ambiguity 
and a match between precedences,  
the parser must build the tree corresponding
to a left parenthesization. Thus, <code>4-5-9</code> 
is interpreted as  <code>(4-5)-9</code>.

<P>
As was said, the <code>%prec</code> directive can be used when
a rhs is involved in a conflict and has no tokens
inside or it has but the precedence of the last token leads
to an incorrect interpretation. A rhs can be followed by 
an optional <code>%prec token</code> directive
giving the production the precedence of the <code>token</code>

<P>
<PRE>
exp:   '-' exp %prec NEG { -$_[1] }
</PRE>
This solves  the conflict in <code>- NUM - NUM</code>
between <code>(- NUM) - NUM</code> and
<TT>- (NUM - NUM)</TT>. Since <code>NEG</code> has more
priority than <code>'-'</code> the first interpretation 
will win.

<P>

<H2><A NAME="SECTION00052000000000000000">
Building the AST</A>
</H2>
<code>Parse::Eyapp</code> facilitates the construction of 
abstract syntax trees (AST) through the <code>%tree</code>
directive. 
Nodes in the AST are blessed in the production
<code>name</code>. 
A rhs can be 
<I>named</I> using the <code>%name IDENTIFIER</code> directive. 
For each <I>rhs name</I> a 
class/package with name <code>IDENTIFIER</code> is created. 

<P>
Symbolic tokens (like <code>NUM</code>
<code>PRINT</code> or <code>VAR</code>) 
are considered by default <I>semantic tokens</I>. 
String literals 
(like <code>'+'</code>, <code>'/'</code>, etc.)
are - unless explictly 
declared using the <TT>semantic token</TT> directive - 
considered <I>syntactic tokens</I>.
When building the AST syntactic tokens do not yield 
new nodes.
Semantic tokens however have their own. Thus
when feed with input <code>b=2*a</code> 
the generated parser
produces the following AST<A NAME="tex2html40"
  HREF="#foot541"><SUP>1</SUP></A>:
<PRE>
~/LEyapp/examples/ParsingStringsAndTrees$ perl -wd infix2pir.pl  # start the debugger

Loading DB routines from perl5db.pl version 1.31
Editor support available.

Enter h or `h h' for help, or `man perldebug' for more help.

main::(infix2pir.pl:48):    my $filename = shift;
  DB&lt;1&gt; l 48,55               # let us see the source code ...
48==&gt;   my $filename = shift;
49: my $parser = Infix-&gt;new(); 
50: $parser-&gt;slurp_file($filename);
51  
52: my $t = $parser-&gt;YYParse();
53  
54  # Machine independent optimizations
55: $t-&gt;s(our @algebra);  
  DB&lt;2&gt; c 55  # continue until the abstract syntax tree (AST) is built
b = 2 * a     # &lt;- user input
main::(infix2pir.pl:55):    $t-&gt;s(our @algebra);  
  DB&lt;3&gt; p $t-&gt;str  # show us the AST
line_3(EXPS(sts_5(ASSIGN(VAR(TERMINAL[b]),TIMES(NUM(TERMINAL[2]),VAR(TERMINAL[a]))))))
</PRE>
Nodes of the AST are hashes that can be 
<I>decorated</I> with new keys/attributes.
The only reserved field is <code>children</code> which is a reference to the
array of children. 
Nodes named <code>TERMINAL</code> are built from the
tokens provided by the lexical analyzer. 
The couple <code>($token, $attribute)</code> returned by the lexical analyzer
is stored under the keys <code>token</code> and <code>attr</code>.
<code>TERMINAL</code> nodes also have the attribute <code>children</code> which is
set to an anonymous empty list.
Observe the absence of <code>TERMINAL</code> nodes corresponding to 
tokens <code>'='</code> and <code>'*'</code>.
If we change the status of <code>'*'</code> and <code>'='</code> 
to <TT>semantic</TT> using the <code>%semantic token</code> directive:
<PRE>
1   %semantic token '*' '='
2   %right  '='
3   ....  etc.
</PRE>
we get a - concrete - syntax tree:
<PRE>
EXPS(
  ASSIGN(
    VAR(TERMINAL[b]),
    TERMINAL[=],
    TIMES(
      NUM(TERMINAL[2]),
      TERMINAL[*],
      VAR(TERMINAL[a])
    ) # TIMES
  ) # ASSIGN
)
</PRE>
Let us now consider the input <code>2*(a+1)</code>.
The parser yields the tree:
<PRE>
EXPS(
  TIMES(
    NUM(
     TERMINAL[2]),
     exp_14(
       PLUS(
         VAR(TERMINAL[a]),
         NUM(TERMINAL[1]))
       ) # PLUS
  ) # TIMES
)
</PRE>
Two features are noticeable: the parenthesis rule <code>exp:</code> <code>'(' exp ')'</code>
had no name
and got automatically one: <code>exp_14</code>. The <I>name of a rhs</I> by 
default results from concatenating the left hand side of the rule
with the ordinal number of the rule<A NAME="tex2html41"
  HREF="#foot542"><SUP>2</SUP></A>.
The second is that node <code>exp_14</code> is useless and can be suppressed. 

<P>
The <code>%tree</code> directive can be accompanied of the <code>%bypass</code>
clause.  A <code>%tree bypass</code> produces an automatic <I>bypass</I> of any
node with only one child at <I>tree-construction-time</I>. 
A <I>bypass operation</I> consists in <I>returning the only child 
of the node being visited to the father of the node and re-typing (re-blessing)
the node in the name of the production</I><A NAME="tex2html42"
  HREF="#foot517"><SUP>3</SUP></A>. 

<P>
Changing the line <code>%tree</code> by <code>%tree bypass</code>
in file <code>Infix.eyp</code> we get a more suitable 
AST for input <code>2*(a+1)</code>:

<P>
<PRE>
EXPS(TIMES(NUM[2],PLUS(VAR[a],NUM[1])))
</PRE>

<P>
The node <code>exp_14</code> has disapeared in this version
since the <I>bypass operation</I> applies to the rhs 
of the rule <code>exp: '(' exp ')'</code>:
Tokens <code>'('</code> and <code>')'</code> are syntactic tokens
and therefore at <I>tree construction time</I>
only one child is left. Observe also the absence 
of <code>TERMINAL</code> nodes. Bypass clearly applies
to rules <code>exp: NUM</code> and <code>exp: VAR</code> since
they have only one element on their rhs. Therefore the
<code>TERMINAL</code> node is re-blessed as <code>NUM</code> and
<code>VAR</code> respectively.

<P>
A consequence of the global scope application of <code>%tree bypass</code>
is that undesired bypasses may occur. Consider the tree 
rendered for input <code>-a*2</code>:

<P>
<PRE>
EXPS(TIMES(NEG,NUM))
</PRE>

<P>
What happened? The bypass is applied to the rhs 
<code>'-' exp</code>.  Though the rhs has two symbols, token <code>'-'</code> is
a syntactic token and at <I>tree-construction-time</I>
only <code>exp</code> is left. The <I>bypass</I>
operation applies when building this node.
This undesired <I>bypass</I> can be avoided applying 
the <code>no bypass</code> directive to the 
production:

<P>
<PRE>
 exp : %no bypass NEG
       '-' exp %prec NEG
</PRE>
Now the AST for <code>-a*2</code> is correct:
<PRE>
EXPS(TIMES(NEG(VAR),NUM))
</PRE>

<P>
Eyapp provides operators <code>+</code>, <code>*</code> and <code>?</code> 
for the creation of lists and optionals as in:
<PRE>
line: sts &lt;EXPS + ';'&gt;
</PRE>
which states that a <TT>line</TT> is made of a non empty
list of <code>EXPS</code> separated by semicolons.
By default the class name for such list is <code>_PLUS_LIST</code>.
The <code>%name</code> directive can be used to modify
the default name:
<PRE>
line: sts &lt;%name EXPS + ';'&gt;
</PRE>

<P>
Explicit actions can be specified by the programmer. 
They are managed as anonymous subroutines
that receive as arguments the attributes of the symbols
in the rule and are executed each time a <I>reduction</I>
by that rule occurs. When running under the <code>%tree</code> directive
this provides a mechanism to influence the shape of the AST.
Observe however that the grammar in the example is <U>clean</U> of actions:
<I>Parse::Eyapp allowed us to produce a suitable AST without writing 
any explicit actions</I>.

<P>

<H1><A NAME="SECTION00060000000000000000"></A>
<A NAME="section:machineindependentoptimizations"></A><BR>
Tree Transformations
</H1>
Once we have the AST we can transform it
using the <I>Treeregexp</I> language.
The code below (in file <code>I2PIR.trg</code>)
shows a set of algebraic tree transformations
whose goal is to produce 
machine independent optimizations.
<PRE>
{ #  Example of support code
  use List::Util qw(reduce);
  my %Op = (PLUS=&gt;'+', MINUS =&gt; '-', TIMES=&gt;'*', DIV =&gt; '/');
}

algebra = fold wxz zxw neg;

fold: /TIMES|PLUS|DIV|MINUS/:b(NUM, NUM) =&gt; { 
  my $op = $Op{ref($b)};
    croak "Unexpected tree shape: ".$_[0]-&gt;str." can't find number in the expected place\n" 
  unless exists ($NUM[0]-&gt;{attr}) &amp;&amp; ($NUM[0]-&gt;{attr} =~ /^\d+/);

  $NUM[0]-&gt;{attr} = eval  "$NUM[0]-&gt;{attr} $op $NUM[1]-&gt;{attr}";
  $_[0] = $NUM[0]; 
}

zxw: TIMES(NUM, .) and {$NUM-&gt;{attr} == 0} =&gt; { $_[0] = $NUM }

wxz: TIMES(., NUM) and {$NUM-&gt;{attr} == 0} =&gt; { $_[0] = $NUM }

neg: NEG(NUM) =&gt; { $NUM-&gt;{attr} = -$NUM-&gt;{attr}; $_[0] = $NUM }
</PRE>
A Treeregexp programs is made of <I>treeregexp</I> rules
that describe what subtrees match and how transform them:
<PRE>
wxz: TIMES(., NUM) and {$NUM-&gt;{attr}==0} =&gt; { $_[0] = $NUM }
</PRE>
This rule comes to say 
<BLOCKQUOTE>
Wherever you find a node labelled <code>TIMES</code> whose right
child is a <code>NUM</code> node and the value of such <code>NUM</code> is
zero, 
<I>whatever the left child subtree is</I> proceed to
substitute the whole tree by its right child, i.e. by zero.
</BLOCKQUOTE>
<P>

<P>
A rule has a <I>name</I> (<code>wxz</code> in the example. <code>wxz</code>
stands for <I>whatever times zero</I>), 
a <I>term</I> describing
the shape of the subtree to match <code>"TIMES(., NUM)"</code>
and two optional fields:
a <I>semantic condition</I> expliciting
the attribute constraints (the code after the reserved word
<code>and</code>)
and some <I>transformation code</I> that tells how to 
modify the subtree (the code after the big arrow <code>=&gt;</code>).
Each rule is translated into a subroutine 
<A NAME="tex2html43"
  HREF="#foot751"><SUP>4</SUP></A>with name the treerexexp rule <I>name</I>.
Therefore, after compilation 
a subroutine <code>wxz</code> will be available.
The dot in the <I>term</I> <code>TIMES(., NUM)</code> 
matches any tree. The semantic condition
states that the <code>attr</code> entry of node
<code>NUM</code> must be zero.
The <I>transformation code</I> - that will be 
applied only if the matching succeeded -
substitutes the whole subtree by its 
right child.

<P>
References to the nodes associated with some
<code>CLASS</code> appearing in the <I>term</I>
section can be accessed inside the semantic parts
through the lexical variable <code>$CLASS</code>.
If there is more than one node the 
associated variable is <code>@CLASS</code>. Variable <code>$_[0]</code>
refers to the root of the subtree that matched.

<P>
Nodes inside a <I>term</I> can be described using linear
regular expressions like in the <code>fold</code> transformation:
<PRE>
/TIMES|PLUS|DIV|MINUS/:b(NUM, NUM)
</PRE>
In such cases an optional identifier 
to later refer the node that matched 
can be specified (<code>b</code> in the example).

<P>
Tree transformations can be grouped in families:

<P>
<PRE>
algebra = fold wxz zxw neg;
</PRE>

<P>
Such families - and the objects they collect - are 
available inside the client program (read anew the code
of the driver in section <A HREF="#section:phases">3</A>). Thus,
if <code>$t</code> holds the AST resulting
from the parsing phase, we can call
its method <code>s</code> (for substitute)
with args the <code>@algebra</code> family:
<PRE>
$t-&gt;s(our @algebra);
</PRE>

<P>
The <code>s</code> method of 
<code>Parse::Eyapp::Node</code><A NAME="tex2html44"
  HREF="#foot752"><SUP>5</SUP></A>proceeds to apply all the transformation in the family
<code>@algebra</code> to tree <code>$t</code>
until none of them matches. Thus, for input
<code>a = 2*(a+b)*(2-4/2)</code> the parser
produces the following tree:
<PRE>
~/LEyapp/examples/ParsingStringsAndTrees$ perl -wd infix2pir.pl

Loading DB routines from perl5db.pl version 1.31
Editor support available.

Enter h or `h h' for help, or `man perldebug' for more help.

main::(infix2pir.pl:41):    my $filename = shift;
  DB&lt;1&gt; l 41,52                                           # let us remind the code involved
41==&gt;   my $filename = shift;
42: my $parser = Infix-&gt;new(); 
43: $parser-&gt;slurp_file($filename);
44  
45: my $t = $parser-&gt;YYParse() || exit(1);
46  
47  # Machine independent optimizations
48: $t-&gt;s(our @algebra);  
49  
50  # Address Assignment 
51: our $reg_assign;
52: $reg_assign-&gt;s($t);
  DB&lt;2&gt; c 48                                               # get input and build the AST
a = 2*(a+b)*(2-4/2)
main::(infix2pir.pl:48):    $t-&gt;s(our @algebra);  
  DB&lt;3&gt; p $t-&gt;str
EXPS(ASSIGN(VAR[a],TIMES(TIMES(NUM[2],PLUS(VAR[a],VAR[b])),MINUS(NUM[2],DIV(NUM[4],NUM[2])))))
</PRE>
Which is transformed by the call <code>$t-&gt;s(@algebra)</code> onto this optimized version:
<PRE>
  DB&lt;4&gt; n
main::(infix2pir.pl:51):    our $reg_assign;
  DB&lt;4&gt; p $t-&gt;str
EXPS(ASSIGN(VAR[a],NUM[0]))
</PRE>
<PRE>
EXPS(ASSIGN(VAR[a],NUM[0]))
</PRE>

<P>

<P>

<H1><A NAME="SECTION00070000000000000000"></A>
<A NAME="section:addressassign"></A><BR>
Resource Allocation
</H1>
The back-end of the translator starts with resource assignment.
The only resource to consider here is memory. We have to assign
a memory location and/or machine register to each of the variables and inner nodes
in the AST. The final target machine, Parrot, is a register based 
interpreter with 32 floating point registers. On top of the Parrot
machine is a layer named Parrot Intermediate Representation (PIR).
The PIR language and its compiler (<code>imcc</code>) make remarkably easier 
the task of mapping variables to registers:
PIR provides an infinite number of virtual
numeric registers named <code>$N1</code>, <code>$N2</code>, etc. and solves
the problem of mapping variables into registers via Graph Coloring
[<A
 HREF="theperlreview.html#briggs98register">8</A>].

<P>
As it shows in the code below (in file <code>I2PIR.trg</code>), 
the resource allocation stage
is limited to assign virtual registers
to the inner nodes:

<P>
<PRE>
    {{ my $num = 1; # closure
      sub new_N_register {
        return '$N'.$num++;
      }
    }}

    reg_assign: $x  =&gt; {
      if (ref($x) =~ /VAR|NUM/) {
        $x-&gt;{reg} = $x-&gt;{attr};
        return 1;
      }
      if (ref($x) =~ /ASSIGN/) {
        $x-&gt;{reg} = $x-&gt;child(0)-&gt;{attr};
        return 1;
      }
      $_[0]-&gt;{reg} = new_N_register();
    }
</PRE>

<P>
A treeregexp term like <code>$x</code> matches any node
and creates a lexical variable <code>$x</code>
containing a reference to the node that matched.

<P>
In between Treeregexp rules the programmer can insert 
Perl code between curly brackets. 
The code will be inserted verbatim<A NAME="tex2html45"
  HREF="#foot841"><SUP>6</SUP></A> at that relative point by the <code>treereg</code>
compiler. 

<P>
The <code>Parse::Eyapp::YATW</code> object <code>$reg_assign</code>
generated by the compiler is available inside
the main driver (revise section <A HREF="#section:phases">3</A>):
<PRE>
our $reg_assign;
      $reg_assign-&gt;s($t);
</PRE>
Now we have an AST <I>decorated</I> with a new attribute <code>reg</code>.
The following session with the debugger illustrates 
the way to expose the AST and its attributes:
<PRE>
    ~/LEyapp/examples/ParsingStringsAndTrees$ perl -wd infix2pir.pl simple5.inf

    Loading DB routines from perl5db.pl version 1.31
    Editor support available.

    Enter h or `h h' for help, or `man perldebug' for more help.

    main::(infix2pir.pl:41):    my $filename = shift;
      DB&lt;1&gt; l 41,55
    41==&gt;   my $filename = shift;
    42: my $parser = Infix-&gt;new(); 
    43: $parser-&gt;slurp_file($filename);
    44  
    45: my $t = $parser-&gt;YYParse() || exit(1);
    46  
    47  # Machine independent optimizations
    48: $t-&gt;s(our @algebra);  
    49  
    50  # Address Assignment 
    51: our $reg_assign;
    52: $reg_assign-&gt;s($t);
    53  
    54  # Translate to PARROT
    55: $t-&gt;bud(our @translation);
      DB&lt;2&gt; c 52
    main::(infix2pir.pl:52):    $reg_assign-&gt;s($t);
      DB&lt;3&gt; x $t-&gt;str
    0  'EXPS(TIMES(NEG(VAR[a]),NUM[2]))'
</PRE>
We have stopped the execution just before the 
call to <code>$reg_assign-&gt;s($t)</code>. The AST
for input <code>-a*2</code> was displayed. Now let us execute
<code>$reg_assign-&gt;s($t)</code>:
<PRE>
  DB&lt;4&gt; n
main::(infix2pir.pl:55):    $t-&gt;bud(our @translation);
</PRE>
And have a look at how registers have been allocated:

<P>
<PRE>
  DB&lt;4&gt; *TIMES::info=*NEG::info=*VAR::info=*NUM::info=sub {$_[0]{reg}}

  DB&lt;5&gt; $Parse::Eyapp::Node::INDENT=2

  DB&lt;6&gt; x $t-&gt;str
0  '
EXPS(
  TIMES[$N2](
    NEG[$N1](
      VAR[a]
    ),
    NUM[2]
  ) # TIMES
) # EXPS'
  DB&lt;7&gt;
</PRE>
Observe that no registers
were allocated for variables and numbers.

<P>
After the register assignment phase
the nodes have been decorated with
the attribute <code>$reg</code>. 

<P>
To display
the tree we use the <code>str</code> method
of the AST nodes. This method is inherited from <code>Parse::Eyapp::Node</code>. 
The <code>str</code> method traverses the syntax tree dumping the type
of the node being visited in a string. If the node being visited
has a method <code>info</code> it will
be executed and its result inserted between <code>$DELIMITER</code>s
into the string. The <code>Parse::Eyapp::Node</code> variable 
<code>$INDENT</code><A NAME="tex2html46"
  HREF="#foot842"><SUP>7</SUP></A>controls the way the tree is displayed. 

<P>

<H1><A NAME="SECTION00080000000000000000"></A>
<A NAME="section:codegeneration"></A><BR>
Code Generation
</H1>
The translation is approached as a particular case of 
<I>tree decoration</I>. Each node is decorated with a new
attribute <code>trans</code>  that will held 
the translation for such node.
To compute it, we define  a translation transformation
<code>t_class</code> for each type of node <code>class</code> in the AST:
<PRE>
    translation = t_num t_var t_op t_neg t_assign t_list t_print;
</PRE>

<P>
Some of these transformations are straightforward. 
The translation of a <code>NUM</code> node is its value:
<PRE>
    t_num: NUM =&gt; { $NUM-&gt;{tr} = $NUM-&gt;{attr} }
</PRE>
The translation of a binary operation node <code>$b</code>
is to apply the associated
binary operator <code>$op</code> to the registers <code>$x-&gt;{reg}</code> 
and <code>$y-&gt;{reg}</code> where
the operands were stored and store it in the register
<code>$b-&gt;{reg}</code> associated with the node:
<PRE>
    t_op:  /TIMES|PLUS|DIV|MINUS/:b($x, $y) =&gt; {
        my $op = $Op{ref($b)};
        $b-&gt;{tr} = "$b-&gt;{reg} = $x-&gt;{reg} $op $y-&gt;{reg}";
      }
</PRE>
To keep track of the involved variables
a hash is used as a rudimentary symbol table:
<PRE>
    { our %s; }
    t_assign: ASSIGN($v, $e) =&gt; {
      $s{$v-&gt;{attr}} = "num";
      $ASSIGN-&gt;{tr} = "$v-&gt;{reg} = $e-&gt;{reg}"
    }
</PRE>
The former rule says that the translation of an
<code>ASSIGN</code> node consists in assigning the contents
of the register assigned to the expression subtree 
to the register assigned to the left hand side.

<P>
The translation of the root node (<code>EXPS</code>)
consists of concatenating the translations
of its children:
<PRE>
{
  sub cat_trans {
    my $t = shift;

    my $tr = "";
    for ($t-&gt;children) {
      (ref($_) =~ m{NUM|VAR|TERMINAL})
        or $tr .= cat_trans($_)."\n"
    }
    $tr .= $t-&gt;{tr} ;
  }
}

t_list: EXPS(@S)
  =&gt; {
    $EXPS-&gt;{tr} = "";
    my @tr = map { cat_trans($_) } @S;
    $EXPS-&gt;{tr} =
      reduce { "$a\n$b" } @tr if @tr;
  }
</PRE>
The treeregexp <code>@S</code> matches the children
of the <code>EXPS</code> node. The associated lexical variable <code>@S</code> 
contains the references to the nodes that 
matched.

<P>
The method <code>bud</code><A NAME="tex2html47"
  HREF="#foot898"><SUP>8</SUP></A>of <code>Parse::Eyapp::Node</code> nodes makes a bootom up traversing
of the AST applying to the node being visited the only one transformation that 
matches<A NAME="tex2html48"
  HREF="#foot899"><SUP>9</SUP></A>.
After the call 
<PRE>
$t-&gt;bud(our @translation);
</PRE>
the attribute <code>$t-&gt;{trans}</code> contains 
a translation to PIR for the whole tree.

<P>

<H1><A NAME="SECTION00090000000000000000"></A>
<A NAME="section:peephole"></A><BR>
Peephole Transformations
</H1>
The name <I>peephole optimizer</I> comes from
the image of sliding a small window 
over the target code attempting to 
replace patterns of instructions 
by better ones. If we have a look at the code 
generated in the previous phase for the input
<code>a = 5-b*2</code>
we see that produces:
<PRE>
    $N1 = b * 2
    $N2 = 5 - $N1
    a = $N2
</PRE>
PIR allows memory instructions involving 
three arguments like <code>a = b + c</code>.
This fact and the observation that <code>$N2</code> 
is used only once 
lead us to conclude that 
the former translation can be changed to:
<PRE>
    $N1 = b * 2
    a = 5 - $N1
</PRE>
Perl regular expressions constitute a formidable
tool to implement <I>peephole optimization</I>. The
regexp below finds patterns 
<PRE>
    $N# = something
    IDENT = $N#
</PRE>
and substitutes them by <code>IDENT = something</code>:
<PRE>
sub peephole_optimization {
  $_[0] =~ s{
             (\$N\d+)\s*=\s*(.*\n)\s*  # $N#num     = ... something ...
             ([a-zA-Z_]\w*)\s*=\s*\1   # IDENTIFIER = $N#num
            } 
            {$3 = $2}gx;               # IDENTIFIER = ... something ...
}
</PRE>

<P>

<H1><A NAME="SECTION000100000000000000000"></A>
<A NAME="section:output"></A><BR>
Output Generation
</H1>
Emitting the code is the simplest of all phases.
Since Parrot requires all the variables to be declared,
a comma separated string <code>$dec</code>  is built
concatenating the keys of the symbol table hash <code>%s</code>.
The code is then indented and the different components
are articulated through a HERE document:
<PRE>
    sub output_code {
      my ($trans, $dec) = @_;

      # Indent
      $$trans =~ s/^/\t/gm;

      # Output the code
    print &lt;&lt; "TRANSLATION";
    .sub 'main' :main
    \t.local num $$dec
    $$trans
    .end
    TRANSLATION
</PRE>
The call to <code>output_code</code> finishes the job:
<PRE>
    output_code(\$t-&gt;{trans}, \$dec);
</PRE>

<P>

<H1><A NAME="SECTION000110000000000000000">
Conclusions and Future Work</A>
</H1>

<P>
This work presented <TT>Parse::Eyapp</TT>, a work in progress in that direction.
<TT>Yacc</TT> and <TT>Parse::Yapp</TT> programmers will feel at home
in <TT>Parse::Eyapp</TT>. 
Additionally to the beneficial mature approach to parsing provided by
<TT>Yacc</TT>-like parser generators,
<TT>Parse::Eyapp</TT> delivers a set of extensions
that give support to the later phases
of text processing.

<P>

<H1><A NAME="SECTION000120000000000000000">
About the Author</A>
</H1>
Casiano Rodriguez-Leon is a Professor of Computer Science at Universidad
de La Laguna. His research focuses on Parallel Computing. 

<P>

<H1><A NAME="SECTION000130000000000000000">
Acknowledgements</A>
</H1>

<P>
This work has been supported by the EC (FEDER) and by
the Spanish Ministry of Education and Science inside the
`Plan Nacional de <SMALL>I+D+</SMALL>i'.
Thanks To Francois Desarmenien. <TT>Parse::Eyapp</TT> shares a large percentage 
of code with <TT>Parse::Yapp</TT>.

<P>

<H2><A NAME="SECTION000140000000000000000">
Bibliography</A>
</H2><DL COMPACT><DD><P></P><DT><A NAME="conwayrd">1</A>
<DD>
Damian Conway.
<BR><EM>Parse::RecDescent, Generate Recursive-Descent Parsers</EM>.
<BR>CPAN, 2003.

<P></P><DT><A NAME="desarmenien">2</A>
<DD>
Francois Desarmenien.
<BR><EM>Parse::Yapp, Perl extension for generating and using LALR
  parsers</EM>.
<BR>CPAN, 2001.

<P></P><DT><A NAME="randal04">3</A>
<DD>
Allison Randal, Dan Sugalski, and Leopold Toetsch.
<BR><EM>Perl 6 and Parrot Essentials, Second Edition</EM>.
<BR>O'Reilly Media, Inc., 2004.

<P></P><DT><A NAME="parrot">4</A>
<DD>
The&nbsp;Parrot Group.
<BR><EM>Parrot Documentation</EM>.
<BR>http://docs.parrot.org/, http://www.parrot.org/people.

<P></P><DT><A NAME="simoes">5</A>
<DD>
Alberto&nbsp;Manuel Simoes.
<BR>Cooking Perl with flex.
<BR><EM>The Perl Review</EM>, 0(3), May 2002.

<P></P><DT><A NAME="Tambouras">6</A>
<DD>
Ioannis Tambouras.
<BR><EM>Parse::Flex, The Fastest Lexer in the West</EM>.
<BR>CPAN, 2006.

<P></P><DT><A NAME="yacc">7</A>
<DD>
Stephen&nbsp;C. Johnson and Ravi Sethi.
<BR>Yacc: a Parser Generator.
<BR><EM>UNIX Vol. II: research system (10th ed.)</EM>, pages 347-374, 1990.

<P></P><DT><A NAME="briggs98register">8</A>
<DD>
Preston Briggs.
<BR>Register Allocation via Graph Coloring.
<BR>Technical Report TR92-183, 24, 1998.
</DL>

<P>
<A NAME="end:of:file"></A>
<P>

<H1><A NAME="SECTION000150000000000000000">
About this document ...</A>
</H1>
 <STRONG>Parsing Strings and Trees with <TT>Parse::Eyapp</TT>
<BR><I>(An Introduction to Compiler Construction)</I></STRONG><P>
This document was generated using the
<A HREF="http://www.latex2html.org/"><STRONG>LaTeX</STRONG>2<tt>HTML</tt></A> translator Version 2008 (1.71)
<P>
Copyright &#169; 1993, 1994, 1995, 1996,
<A HREF="http://cbl.leeds.ac.uk/nikos/personal.html">Nikos Drakos</A>, 
Computer Based Learning Unit, University of Leeds.
<BR>Copyright &#169; 1997, 1998, 1999,
<A HREF="http://www.maths.mq.edu.au/~ross/">Ross Moore</A>, 
Mathematics Department, Macquarie University, Sydney.
<P>
The command line arguments were: <BR>
 <STRONG>latex2html</STRONG> <TT>-split 0 theperlreview</TT>
<P>
The translation was initiated by casiano on 2010-01-03<BR><HR><H4>Footnotes</H4>
<DL>
<DT><A NAME="foot541">... AST</A><A
 HREF="theperlreview.html#tex2html40"><SUP>1</SUP></A></DT>
<DD>The information
between brackets shows the attribute 
for <TT>TERMINAL</TT> nodes

</DD>
<DT><A NAME="foot542">... rule</A><A
 HREF="theperlreview.html#tex2html41"><SUP>2</SUP></A></DT>
<DD>As it appears
in the <TT>.output</TT> file. The <TT>.output</TT> file can be generated 
using the <TT>-v</TT> option of <TT>eyapp</TT>

</DD>
<DT><A NAME="foot517">... production</I></A><A
 HREF="theperlreview.html#tex2html42"><SUP>3</SUP></A></DT>
<DD>If the production has an
explicit name. Otherwise there is no re-blessing

</DD>
<DT><A NAME="foot751">... subroutine</A><A
 HREF="theperlreview.html#tex2html43"><SUP>4</SUP></A></DT>
<DD>The sub must be accessed 
through a proxy 
<TT>Parse::Eyapp::YATW</TT> object. YATW stands for <I>Yet Another Tree Walker</I>

</DD>
<DT><A NAME="foot752">...
<code>Parse::Eyapp::Node</code></A><A
 HREF="theperlreview.html#tex2html44"><SUP>5</SUP></A></DT>
<DD>All the classes in the AST
inherit from <TT>Parse::Eyapp::Node</TT>

</DD>
<DT><A NAME="foot841">... verbatim</A><A
 HREF="theperlreview.html#tex2html45"><SUP>6</SUP></A></DT>
<DD>Without 
the outer curly brackets.
If it weren't for the second pair of curly brackets
the lexical variable <TT>$num</TT> would be visible
up to the end of the file


</DD>
<DT><A NAME="foot842">...
<code>$INDENT</code></A><A
 HREF="theperlreview.html#tex2html46"><SUP>7</SUP></A></DT>
<DD>Other <TT>Parse::Eyapp::Node</TT>
variables governing the behavior of <TT>str</TT> are:
<TT>PREFIXES</TT>,
<TT>$STRSEP</TT>,
<TT>$FOOTNOTE_HEADER</TT>,
<TT>$FOOTNOTE_SEP</TT>,
<TT>$FOOTNOTE_LEFT</TT>,
<TT>$FOOTNOTE_RIGHT</TT> 
and
<TT>$LINESEP</TT>


</DD>
<DT><A NAME="foot898">... <code>bud</code></A><A
 HREF="theperlreview.html#tex2html47"><SUP>8</SUP></A></DT>
<DD><U>B</U>ottom-<U>U</U>p <U>D</U>ecorator

</DD>
<DT><A NAME="foot899">...
matches</A><A
 HREF="theperlreview.html#tex2html48"><SUP>9</SUP></A></DT>
<DD>When <TT>bud</TT> is applied the family of transformations <U>must</U> constitute
a <I>partition</I> of the AST classes, i.e. for each node one and only one
transformation matches

</DD>
</DL><HR>
<!--Navigation Panel-->
<IMG WIDTH="81" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="next_inactive"
 SRC="file:/opt/local/share/lib/latex2html/icons/nx_grp_g.png"> 
<IMG WIDTH="26" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="up"
 SRC="file:/opt/local/share/lib/latex2html/icons/up_g.png"> 
<IMG WIDTH="63" HEIGHT="24" ALIGN="BOTTOM" BORDER="0" ALT="previous"
 SRC="file:/opt/local/share/lib/latex2html/icons/prev_g.png">   
  <A NAME="tex2html1"
  HREF="http://nereida.deioc.ull.es/~pl/eyapsimple/source.tgz"><IMG
  WIDTH="23" ALIGN="BOTTOM" BORDER="0"
 SRC="gzip.png"
 ALT="SRC"></A>

  <A NAME="tex2html2"
  HREF="http://nereida.deioc.ull.es/~pl/eyapsimple/eyapsimple.dvi"><IMG
  WIDTH="23" ALIGN="BOTTOM" BORDER="0"
 SRC="xdviicon.gif"
 ALT="DVI"></A>
<A NAME="tex2html3"
  HREF="eyapsimple.ps"><IMG
  WIDTH="24" ALIGN="BOTTOM" BORDER="0"
 SRC="gv.jpeg"
 ALT="eyapsimple.ps"></A><A NAME="tex2html4"
  HREF="eyapsimple.pdf"><IMG
  WIDTH="24" ALIGN="BOTTOM" BORDER="0"
 SRC="pdf_logo.jpg"
 ALT="eyapsimple.pdf"></A><A NAME="tex2html5"
  HREF="http://search.cpan.org/dist/Parse-Eyapp/"><IMG
  WIDTH="60" ALIGN="BOTTOM" BORDER="0"
 SRC="lupa.gif"
 ALT="modulos"></A><A NAME="tex2html6"
  HREF="../perlexamples/"><IMG
  WIDTH="35" ALIGN="BOTTOM" BORDER="0"
 SRC="dragon_tree4.jpg"
 ALT="apuntes"></A><A NAME="tex2html7"
  HREF="http://www.parrot.org/"><IMG
  WIDTH="70" ALIGN="BOTTOM" BORDER="0"
 SRC="parrotify_logo.png"
 ALT="modulos"></A>
<BR>
<!--End of Navigation Panel-->
<ADDRESS>
casiano
2010-01-03
</ADDRESS>
</BODY>
</HTML>
